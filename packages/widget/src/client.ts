import { TravrseChatConfig, TravrseMessage, TravrseChatEvent } from "./types";

type DispatchOptions = {
  messages: TravrseMessage[];
  signal?: AbortSignal;
};

type SSEHandler = (event: TravrseChatEvent) => void;

const DEFAULT_ENDPOINT = "https://api.travrse.ai/v1/dispatch";

export class TravrseChatClient {
  private readonly apiUrl: string;
  private readonly headers: Record<string, string>;
  private readonly debug: boolean;

  constructor(private config: TravrseChatConfig = {}) {
    this.apiUrl = config.apiUrl ?? DEFAULT_ENDPOINT;
    this.headers = {
      "Content-Type": "application/json",
      ...config.headers
    };
    this.debug = Boolean(config.debug);
  }

  public async dispatch(options: DispatchOptions, onEvent: SSEHandler) {
    const controller = new AbortController();
    if (options.signal) {
      options.signal.addEventListener("abort", () => controller.abort());
    }

    onEvent({ type: "status", status: "connecting" });
    const body = this.buildRequestBody(options.messages);
    if (this.debug) {
      // eslint-disable-next-line no-console
      console.debug("[TravrseChatClient] dispatch body", body);
    }

    const response = await fetch(this.apiUrl, {
      method: "POST",
      headers: this.headers,
      body: JSON.stringify(body),
      signal: controller.signal
    });

    if (!response.ok || !response.body) {
      const error = new Error(
        `Travrse API request failed: ${response.status} ${response.statusText}`
      );
      onEvent({ type: "error", error });
      throw error;
    }

    onEvent({ type: "status", status: "connected" });
    try {
      await this.streamResponse(response.body, onEvent);
    } finally {
      onEvent({ type: "status", status: "idle" });
    }
  }

  private buildRequestBody(messages: TravrseMessage[]) {
    const previousMessages = messages.slice(0, -1).filter((m) => m.role !== "system");
    const formattedPrevious = previousMessages.map((message) => ({
      role: message.role,
      content: message.content,
      created_at: message.createdAt
    }));

    return {
      record: {
        name: "Streaming Chat Widget",
        type: "standalone",
        metadata: {
          message: messages[messages.length - 1]?.content,
          previous_messages: formattedPrevious,
          ...(this.config.metadata ?? {})
        }
      },
      flow: {
        name: "Streaming Prompt Flow",
        description: "Streaming chat generated by the widget",
        steps: [
          {
            id: "widget_prompt",
            name: "Prompt",
            type: "prompt",
            enabled: true,
            config: {
              text: "{{_record.metadata.message}}",
              model: "meta/llama3.1-8b-instruct-free",
              responseFormat: "markdown",
              outputVariable: "prompt_result",
              userPrompt: "{{_record.metadata.message}}",
              systemPrompt:
                "you are a helpful assistant, chatting with a user. \n\nprevious messages:\n{{_record.metadata.previous_messages}}"
            }
          }
        ]
      },
      options: {
        stream_response: true,
        record_mode: "virtual",
        flow_mode: "virtual"
      }
    };
  }

  private async streamResponse(
    body: ReadableStream<Uint8Array>,
    onEvent: SSEHandler
  ) {
    const reader = body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";

    const message: TravrseMessage = {
      id: `message-${Date.now()}`,
      role: "assistant",
      content: "",
      createdAt: new Date().toISOString(),
      streaming: true
    };

    onEvent({ type: "message", message });

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const events = buffer.split("\n\n");
      buffer = events.pop() ?? "";

      for (const event of events) {
        const lines = event.split("\n");
        let eventType = "message";
        let data = "";

        for (const line of lines) {
          if (line.startsWith("event:")) {
            eventType = line.replace("event:", "").trim();
          } else if (line.startsWith("data:")) {
            data += line.replace("data:", "").trim();
          }
        }

        if (!data) continue;
        let payload: any;
        try {
          payload = JSON.parse(data);
        } catch (error) {
          onEvent({
            type: "error",
            error:
              error instanceof Error
                ? error
                : new Error("Failed to parse Travrse stream payload")
          });
          continue;
        }

        const payloadType =
          eventType !== "message" ? eventType : payload.type ?? "message";

        if (payloadType === "step_chunk") {
          const chunk = payload.text ?? payload.delta ?? payload.content ?? "";
          if (chunk) {
            message.content += chunk;
            onEvent({ type: "message", message: { ...message } });
          }
          if (payload.isComplete && payload.output?.prompt_result) {
            message.content = payload.output.prompt_result;
            message.streaming = false;
            onEvent({ type: "message", message: { ...message } });
          }
        } else if (payloadType === "step_complete") {
          if (payload.output?.prompt_result) {
            message.content = payload.output.prompt_result;
            message.streaming = false;
            onEvent({ type: "message", message: { ...message } });
          }
        } else if (payloadType === "flow_complete") {
          if (payload.output?.prompt_result) {
            message.content = payload.output.prompt_result;
            onEvent({ type: "message", message: { ...message } });
          }
          message.streaming = false;
          onEvent({ type: "status", status: "idle" });
        } else if (payloadType === "error" && payload.error) {
          onEvent({
            type: "error",
            error:
              payload.error instanceof Error
                ? payload.error
                : new Error(String(payload.error))
          });
        }
      }
    }
  }
}
