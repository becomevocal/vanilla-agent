import { Hono } from "hono";
import type { Context } from "hono";
import { handle } from "hono/vercel";

export type TravrseFlowStep = {
  id: string;
  name: string;
  type: string;
  enabled: boolean;
  config: Record<string, unknown>;
};

export type TravrseFlowConfig = {
  name: string;
  description: string;
  steps: TravrseFlowStep[];
};

export type ChatProxyOptions = {
  upstreamUrl?: string;
  apiKey?: string;
  path?: string;
  allowedOrigins?: string[];
  flowId?: string;
  flowConfig?: TravrseFlowConfig;
};

const DEFAULT_ENDPOINT = "https://api.travrse.ai/v1/dispatch";
const DEFAULT_PATH = "/api/chat/dispatch";

const DEFAULT_FLOW: TravrseFlowConfig = {
  name: "Streaming Prompt Flow",
  description: "Streaming chat generated by the widget",
  steps: [
    {
      id: "widget_prompt",
      name: "Prompt",
      type: "prompt",
      enabled: true,
      config: {
        model: "meta/llama3.1-8b-instruct-free",
        responseFormat: "markdown",
        outputVariable: "prompt_result",
        userPrompt: "{{user_message}}",
        systemPrompt: "you are a helpful assistant, chatting with a user",
        previousMessages: "{{messages}}"
      }
    }
  ]
};

const withCors =
  (allowedOrigins: string[] | undefined) =>
  async (c: Context, next: () => Promise<void>) => {
    const origin = c.req.header("origin") ?? "*";
    const headers: Record<string, string> = {
      "Access-Control-Allow-Origin":
        allowedOrigins && allowedOrigins.length
          ? allowedOrigins.includes(origin)
            ? origin
            : allowedOrigins[0]
          : origin,
      "Access-Control-Allow-Headers":
        c.req.header("access-control-request-headers") ??
        "Content-Type, Authorization",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
      Vary: "Origin"
    };

    if (c.req.method === "OPTIONS") {
      return new Response(null, { status: 204, headers });
    }

    await next();
    Object.entries(headers).forEach(([key, value]) =>
      c.header(key, value, { append: false })
    );
  };

export const createChatProxyApp = (options: ChatProxyOptions = {}) => {
  const app = new Hono();
  const path = options.path ?? DEFAULT_PATH;
  const upstream = options.upstreamUrl ?? DEFAULT_ENDPOINT;

  app.use("*", withCors(options.allowedOrigins));

  app.post(path, async (c) => {
    const apiKey = options.apiKey ?? process.env.TRAVRSE_API_KEY;
    if (!apiKey) {
      return c.json(
        { error: "Missing API key. Set TRAVRSE_API_KEY." },
        401
      );
    }

    let clientPayload: {
      messages?: Array<{ role: string; content: string; createdAt?: string }>;
      flowId?: string;
    };
    try {
      clientPayload = await c.req.json();
    } catch (error) {
      return c.json(
        { error: "Invalid JSON body", details: error },
        400
      );
    }

    // Build the Travrse payload
    const messages = clientPayload.messages ?? [];
    // Sort messages by timestamp to ensure correct order
    const sortedMessages = [...messages].sort((a, b) => {
      const timeA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
      const timeB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
      return timeA - timeB;
    });
    const formattedMessages = sortedMessages.map((message) => ({
      role: message.role,
      content: message.content
    }));

    // Determine which flow to use
    const flowId = clientPayload.flowId ?? options.flowId;
    const flowConfig = options.flowConfig ?? DEFAULT_FLOW;

    const travrsePayload: Record<string, unknown> = {
      record: {
        name: "Streaming Chat Widget",
        type: "standalone",
        metadata: {}
      },
      messages: formattedMessages,
      options: {
        stream_response: true,
        record_mode: "virtual",
        flow_mode: flowId ? "existing" : "virtual",
        auto_append_metadata: false
      }
    };

    // Use flow ID if provided, otherwise use flow config
    if (flowId) {
      travrsePayload.flow =  {
        id: flowId,
      }
    } else {
      travrsePayload.flow = flowConfig;
    }

    const response = await fetch(upstream, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(travrsePayload)
    });

    return new Response(response.body, {
      status: response.status,
      headers: {
        "Content-Type":
          response.headers.get("content-type") ?? "application/json",
        "Cache-Control": "no-store"
      }
    });
  });

  return app;
};

export const createVercelHandler = (options?: ChatProxyOptions) =>
  handle(createChatProxyApp(options));


export default createChatProxyApp;
