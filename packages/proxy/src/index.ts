import { Hono } from "hono";
import type { Context } from "hono";
import { handle } from "hono/vercel";

export type TravrseFlowStep = {
  id: string;
  name: string;
  type: string;
  enabled: boolean;
  config: Record<string, unknown>;
};

export type TravrseFlowConfig = {
  name: string;
  description: string;
  steps: TravrseFlowStep[];
};

export type ChatProxyOptions = {
  upstreamUrl?: string;
  apiKey?: string;
  path?: string;
  allowedOrigins?: string[];
  flowId?: string;
  flowConfig?: TravrseFlowConfig;
};

const DEFAULT_ENDPOINT = "https://api.travrse.ai/v1/dispatch";
const DEFAULT_PATH = "/api/chat/dispatch";

const DEFAULT_FLOW: TravrseFlowConfig = {
  name: "Streaming Prompt Flow",
  description: "Streaming chat generated by the widget",
  steps: [
    {
      id: "widget_prompt",
      name: "Prompt",
      type: "prompt",
      enabled: true,
      config: {
        model: "meta/llama3.1-8b-instruct-free",
        // model: "gpt-4o",
        response_format: "markdown",
        output_variable: "prompt_result",
        user_prompt: "{{user_message}}",
        system_prompt: "you are a helpful assistant, chatting with a user",
        // tools: {
        //   tool_ids: [
        //     "builtin:dalle"
        //   ]
        // },
        previous_messages: "{{messages}}"
      }
    }
  ]
};

const withCors =
  (allowedOrigins: string[] | undefined) =>
    async (c: Context, next: () => Promise<void>) => {
      const origin = c.req.header("origin") ?? "*";
      const headers: Record<string, string> = {
        "Access-Control-Allow-Origin":
          allowedOrigins && allowedOrigins.length
            ? allowedOrigins.includes(origin)
              ? origin
              : allowedOrigins[0]
            : origin,
        "Access-Control-Allow-Headers":
          c.req.header("access-control-request-headers") ??
          "Content-Type, Authorization",
        "Access-Control-Allow-Methods": "POST, OPTIONS",
        Vary: "Origin"
      };

      if (c.req.method === "OPTIONS") {
        return new Response(null, { status: 204, headers });
      }

      await next();
      Object.entries(headers).forEach(([key, value]) =>
        c.header(key, value, { append: false })
      );
    };

export const createChatProxyApp = (options: ChatProxyOptions = {}) => {
  const app = new Hono();
  const path = options.path ?? DEFAULT_PATH;
  const upstream = options.upstreamUrl ?? DEFAULT_ENDPOINT;

  app.use("*", withCors(options.allowedOrigins));

  app.post(path, async (c) => {
    const apiKey = options.apiKey ?? process.env.TRAVRSE_API_KEY;
    if (!apiKey) {
      return c.json(
        { error: "Missing API key. Set TRAVRSE_API_KEY." },
        401
      );
    }

    let clientPayload: {
      messages?: Array<{ role: string; content: string; createdAt?: string }>;
      flowId?: string;
    };
    try {
      clientPayload = await c.req.json();
    } catch (error) {
      return c.json(
        { error: "Invalid JSON body", details: error },
        400
      );
    }

    // Build the Travrse payload
    const messages = clientPayload.messages ?? [];
    // Sort messages by timestamp to ensure correct order
    const sortedMessages = [...messages].sort((a, b) => {
      const timeA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
      const timeB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
      return timeA - timeB;
    });
    const formattedMessages = sortedMessages.map((message) => ({
      role: message.role,
      content: message.content
    }));

    // Determine which flow to use
    const flowId = clientPayload.flowId ?? options.flowId;
    const flowConfig = options.flowConfig ?? DEFAULT_FLOW;

    const travrsePayload: Record<string, unknown> = {
      record: {
        name: "Streaming Chat Widget",
        type: "standalone",
        metadata: {}
      },
      messages: formattedMessages,
      options: {
        stream_response: true,
        record_mode: "virtual",
        flow_mode: flowId ? "existing" : "virtual",
        auto_append_metadata: false
      }
    };

    // Use flow ID if provided, otherwise use flow config
    if (flowId) {
      travrsePayload.flow = {
        "name": "Chat with 8b",
        "description": "Flow with 1 step",
        "steps": [
          {
            "id": "step_01k8wnwpdcferbrq79tzj49aec",
            "name": "Prompt 1",
            "type": "prompt",
            "order": 0,
            "enabled": true,
            "config": {
              "text": "{{user_message}}",
              "model": "qwen/qwen3-8b",
              // "tools": {
              //   "tool_ids": [
              //     "tool_01k8ky2xpjfzybye5ywcmjr379",
              //     "builtin:firecrawl"
              //   ]
              // },
              "reasoning": false,
              "user_prompt": "{{user_message}}",
              "output_variable": "prompt_result",
              "response_format": "JSON"
            }
          }
        ]
      }
    } else {
      travrsePayload.flow = flowConfig;
    }

    // Development logging
    const isDevelopment = process.env.NODE_ENV === "development" || !process.env.NODE_ENV;

    if (isDevelopment) {
      console.log("\n=== Travrse Proxy Request ===");
      console.log("URL:", upstream);
      console.log("API Key Used:", apiKey ? "Yes" : "No");
      console.log("API Key (first 12 chars):", apiKey ? apiKey.substring(0, 12) : "N/A");
      console.log("Request Payload:", JSON.stringify(travrsePayload, null, 2));
    }

    const response = await fetch(upstream, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(travrsePayload)
    });

    if (isDevelopment) {
      console.log("Response Status:", response.status);
      console.log("Response Status Text:", response.statusText);

      // If there's an error, try to read and log the response body
      if (!response.ok) {
        const clonedResponse = response.clone();
        try {
          const errorBody = await clonedResponse.text();
          console.log("Error Response Body:", errorBody);
        } catch (e) {
          console.log("Could not read error response body:", e);
        }
      }
      console.log("=== End Travrse Proxy Request ===\n");
    }

    return new Response(response.body, {
      status: response.status,
      headers: {
        "Content-Type":
          response.headers.get("content-type") ?? "application/json",
        "Cache-Control": "no-store"
      }
    });
  });

  return app;
};

export const createVercelHandler = (options?: ChatProxyOptions) =>
  handle(createChatProxyApp(options));


export default createChatProxyApp;

