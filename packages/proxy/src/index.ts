import { Hono } from "hono";
import type { Context } from "hono";
import { handle } from "hono/vercel";

export type TravrseFlowStep = {
  id: string;
  name: string;
  type: string;
  enabled: boolean;
  config: Record<string, unknown>;
};

export type TravrseFlowConfig = {
  name: string;
  description: string;
  steps: TravrseFlowStep[];
};

export type ChatProxyOptions = {
  upstreamUrl?: string;
  apiKey?: string;
  path?: string;
  allowedOrigins?: string[];
  flowId?: string;
  flowConfig?: TravrseFlowConfig;
};

const DEFAULT_ENDPOINT = "https://api.travrse.ai/v1/dispatch";
const DEFAULT_PATH = "/api/chat/dispatch";

const DEFAULT_FLOW: TravrseFlowConfig = {
  name: "Streaming Prompt Flow",
  description: "Streaming chat generated by the widget",
  steps: [
    {
      id: "widget_prompt",
      name: "Prompt",
      type: "prompt",
      enabled: true,
      config: {
        model: "meta/llama3.1-8b-instruct-free",
        // model: "gpt-4o",
        response_format: "markdown",
        output_variable: "prompt_result",
        user_prompt: "{{user_message}}",
        system_prompt: "you are a helpful assistant, chatting with a user",
        // tools: {
        //   tool_ids: [
        //     "builtin:dalle"
        //   ]
        // },
        previous_messages: "{{messages}}"
      }
    }
  ]
};

/**
 * Replace variables in flow configuration for virtual flows
 */
function replaceVariablesInFlow(
  flowConfig: TravrseFlowConfig,
  messages: Array<{ role: string; content: string }>,
  metadata: Record<string, unknown>
): TravrseFlowConfig {
  // Create a deep copy of the flow config
  const config = JSON.parse(JSON.stringify(flowConfig)) as TravrseFlowConfig;

  // Get the last user message for {{user_message}} replacement
  const lastUserMessage = [...messages].reverse().find(msg => msg.role === 'user')?.content || '';

  // Convert messages to the expected format for {{messages}} replacement
  const messagesJson = JSON.stringify(messages);

  // Helper function to replace variables in a string
  function replaceInString(str: string): string {
    if (typeof str !== 'string') return str;

    let result = str;

    // Replace {{user_message}}
    result = result.replace(/\{\{user_message\}\}/g, lastUserMessage);

    // Replace {{messages}}
    result = result.replace(/\{\{messages\}\}/g, messagesJson);

    // Replace {{record.metadata.*}} patterns
    result = result.replace(/\{\{record\.metadata\.([^}]+)\}\}/g, (match, key) => {
      const value = metadata[key];
      if (value === undefined) return match; // Keep original if not found
      return typeof value === 'string' ? value : JSON.stringify(value);
    });

    // Also support {{_record.metadata.*}} pattern for backward compatibility
    result = result.replace(/\{\{_record\.metadata\.([^}]+)\}\}/g, (match, key) => {
      const value = metadata[key];
      if (value === undefined) return match; // Keep original if not found
      return typeof value === 'string' ? value : JSON.stringify(value);
    });

    return result;
  }

  // Recursively replace variables in the config object
  function replaceInObject(obj: any): any {
    if (typeof obj === 'string') {
      return replaceInString(obj);
    } else if (Array.isArray(obj)) {
      return obj.map(replaceInObject);
    } else if (obj && typeof obj === 'object') {
      const result: any = {};
      for (const [key, value] of Object.entries(obj)) {
        result[key] = replaceInObject(value);
      }
      return result;
    }
    return obj;
  }

  return replaceInObject(config);
}

const withCors =
  (allowedOrigins: string[] | undefined) =>
    async (c: Context, next: () => Promise<void>) => {
      const origin = c.req.header("origin");
      const isDevelopment = process.env.NODE_ENV === "development" || !process.env.NODE_ENV;
      
      // Determine the CORS origin to allow
      let corsOrigin: string;
      if (!allowedOrigins || allowedOrigins.length === 0) {
        // No restrictions - allow any origin (or use the request origin)
        corsOrigin = origin || "*";
      } else if (allowedOrigins.includes(origin || "")) {
        // Origin is in the allowed list
        corsOrigin = origin || "*";
      } else if (isDevelopment && origin) {
        // In development, allow the actual origin even if not in the list
        // This helps with local development where ports might vary
        corsOrigin = origin;
      } else {
        // Production: origin not allowed - reject by not setting CORS headers
        // Return error for preflight, or continue without CORS headers
        if (c.req.method === "OPTIONS") {
          return c.json({ error: "CORS policy violation: origin not allowed" }, 403);
        }
        // For non-preflight requests, continue but browser will block due to missing CORS headers
        await next();
        return;
      }

      const headers: Record<string, string> = {
        "Access-Control-Allow-Origin": corsOrigin,
        "Access-Control-Allow-Headers":
          c.req.header("access-control-request-headers") ??
          "Content-Type, Authorization",
        "Access-Control-Allow-Methods": "POST, OPTIONS",
        Vary: "Origin"
      };

      if (c.req.method === "OPTIONS") {
        return new Response(null, { status: 204, headers });
      }

      await next();
      Object.entries(headers).forEach(([key, value]) =>
        c.header(key, value, { append: false })
      );
    };

export const createChatProxyApp = (options: ChatProxyOptions = {}) => {
  const app = new Hono();
  const path = options.path ?? DEFAULT_PATH;
  const upstream = options.upstreamUrl ?? DEFAULT_ENDPOINT;

  app.use("*", withCors(options.allowedOrigins));

  app.post(path, async (c) => {
    const apiKey = options.apiKey ?? process.env.TRAVRSE_API_KEY;
    if (!apiKey) {
      return c.json(
        { error: "Missing API key. Set TRAVRSE_API_KEY." },
        401
      );
    }

    let clientPayload: {
      messages?: Array<{ role: string; content: string; createdAt?: string }>;
      flowId?: string;
      metadata?: Record<string, unknown>;
    };
    try {
      clientPayload = await c.req.json();
    } catch (error) {
      return c.json(
        { error: "Invalid JSON body", details: error },
        400
      );
    }

    // Build the Travrse payload
    const messages = clientPayload.messages ?? [];
    // Sort messages by timestamp to ensure correct order
    const sortedMessages = [...messages].sort((a, b) => {
      const timeA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
      const timeB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
      return timeA - timeB;
    });
    const formattedMessages = sortedMessages.map((message) => ({
      role: message.role,
      content: message.content
    }));

    // Determine which flow to use
    const flowId = clientPayload.flowId ?? options.flowId;
    const flowConfig = options.flowConfig ?? DEFAULT_FLOW;

    const travrsePayload: Record<string, unknown> = {
      record: {
        name: "Streaming Chat Widget",
        type: "standalone",
        metadata: clientPayload.metadata || {}
      },
      messages: formattedMessages,
      options: {
        stream_response: true,
        record_mode: "virtual",
        flow_mode: flowId ? "existing" : "virtual",
        auto_append_metadata: false
      }
    };

    // Use flow ID if provided, otherwise use flow config
    if (flowId) {
      travrsePayload.flow = {
        id: flowId
      }
    } else {
      // For virtual flows, perform client-side variable replacement
      travrsePayload.flow = replaceVariablesInFlow(flowConfig, formattedMessages, clientPayload.metadata || {});
    }

    // Development logging
    const isDevelopment = process.env.NODE_ENV === "development" || !process.env.NODE_ENV;

    if (isDevelopment) {
      console.log("\n=== Travrse Proxy Request ===");
      console.log("URL:", upstream);
      console.log("API Key Used:", apiKey ? "Yes" : "No");
      console.log("API Key (first 12 chars):", apiKey ? apiKey.substring(0, 12) : "N/A");
      console.log("Request Payload:", JSON.stringify(travrsePayload, null, 2));
    }

    const response = await fetch(upstream, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(travrsePayload)
    });

    if (isDevelopment) {
      console.log("Response Status:", response.status);
      console.log("Response Status Text:", response.statusText);

      // If there's an error, try to read and log the response body
      if (!response.ok) {
        const clonedResponse = response.clone();
        try {
          const errorBody = await clonedResponse.text();
          console.log("Error Response Body:", errorBody);
        } catch (e) {
          console.log("Could not read error response body:", e);
        }
      }
      console.log("=== End Travrse Proxy Request ===\n");
    }

    return new Response(response.body, {
      status: response.status,
      headers: {
        "Content-Type":
          response.headers.get("content-type") ?? "application/json",
        "Cache-Control": "no-store"
      }
    });
  });

  return app;
};

export const createVercelHandler = (options?: ChatProxyOptions) =>
  handle(createChatProxyApp(options));

// Export pre-configured flows
export * from "./flows/index.js";

// Export utility functions
export * from "./utils/index.js";

// Export internal functions for testing
export { replaceVariablesInFlow };

export default createChatProxyApp;

