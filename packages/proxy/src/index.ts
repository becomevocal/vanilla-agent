import { Hono } from "hono";
import type { Context } from "hono";
import { handle } from "hono/vercel";

export type TravrseFlowStep = {
  id: string;
  name: string;
  type: string;
  enabled: boolean;
  config: Record<string, unknown>;
};

export type TravrseFlowConfig = {
  name: string;
  description: string;
  steps: TravrseFlowStep[];
};

/**
 * Payload for message feedback (upvote/downvote)
 */
export type FeedbackPayload = {
  type: "upvote" | "downvote";
  messageId: string;
  content?: string;
  timestamp?: string;
  sessionId?: string;
  metadata?: Record<string, unknown>;
};

/**
 * Handler function for processing feedback
 */
export type FeedbackHandler = (feedback: FeedbackPayload) => Promise<void> | void;

export type ChatProxyOptions = {
  upstreamUrl?: string;
  apiKey?: string;
  path?: string;
  allowedOrigins?: string[];
  flowId?: string;
  flowConfig?: TravrseFlowConfig;
  /**
   * Path for the feedback endpoint (default: "/api/feedback")
   */
  feedbackPath?: string;
  /**
   * Custom handler for processing feedback.
   * Use this to store feedback in a database or send to analytics.
   * 
   * @example
   * ```ts
   * onFeedback: async (feedback) => {
   *   await db.feedback.create({ data: feedback });
   * }
   * ```
   */
  onFeedback?: FeedbackHandler;
};

const DEFAULT_ENDPOINT = "https://api.travrse.ai/v1/dispatch";
const DEFAULT_PATH = "/api/chat/dispatch";

const DEFAULT_FLOW: TravrseFlowConfig = {
  name: "Streaming Prompt Flow",
  description: "Streaming chat generated by the widget",
  steps: [
    {
      id: "widget_prompt",
      name: "Prompt",
      type: "prompt",
      enabled: true,
      config: {
        model: "meta/llama3.1-8b-instruct-free",
        // model: "gpt-4o",
        response_format: "markdown",
        output_variable: "prompt_result",
        user_prompt: "{{user_message}}",
        system_prompt: "you are a helpful assistant, chatting with a user",
        // tools: {
        //   tool_ids: [
        //     "builtin:dalle"
        //   ]
        // },
        previous_messages: "{{messages}}"
      }
    }
  ]
};

const withCors =
  (allowedOrigins: string[] | undefined) =>
    async (c: Context, next: () => Promise<void>) => {
      const origin = c.req.header("origin");
      const isDevelopment = process.env.NODE_ENV === "development" || !process.env.NODE_ENV;
      
      // Determine the CORS origin to allow
      let corsOrigin: string;
      if (!allowedOrigins || allowedOrigins.length === 0) {
        // No restrictions - allow any origin (or use the request origin)
        corsOrigin = origin || "*";
      } else if (allowedOrigins.includes(origin || "")) {
        // Origin is in the allowed list
        corsOrigin = origin || "*";
      } else if (isDevelopment && origin) {
        // In development, allow the actual origin even if not in the list
        // This helps with local development where ports might vary
        corsOrigin = origin;
      } else {
        // Production: origin not allowed - reject by not setting CORS headers
        // Return error for preflight, or continue without CORS headers
        if (c.req.method === "OPTIONS") {
          return c.json({ error: "CORS policy violation: origin not allowed" }, 403);
        }
        // For non-preflight requests, continue but browser will block due to missing CORS headers
        await next();
        return;
      }

      const headers: Record<string, string> = {
        "Access-Control-Allow-Origin": corsOrigin,
        "Access-Control-Allow-Headers":
          c.req.header("access-control-request-headers") ??
          "Content-Type, Authorization",
        "Access-Control-Allow-Methods": "POST, OPTIONS",
        Vary: "Origin"
      };

      if (c.req.method === "OPTIONS") {
        return new Response(null, { status: 204, headers });
      }

      await next();
      Object.entries(headers).forEach(([key, value]) =>
        c.header(key, value, { append: false })
      );
    };

export const createChatProxyApp = (options: ChatProxyOptions = {}) => {
  const app = new Hono();
  const path = options.path ?? DEFAULT_PATH;
  const feedbackPath = options.feedbackPath ?? "/api/feedback";
  const upstream = options.upstreamUrl ?? DEFAULT_ENDPOINT;

  app.use("*", withCors(options.allowedOrigins));

  // Feedback endpoint for collecting upvote/downvote data
  app.post(feedbackPath, async (c) => {
    let payload: FeedbackPayload;
    try {
      payload = await c.req.json();
    } catch (error) {
      return c.json({ error: "Invalid JSON body" }, 400);
    }

    // Validate payload
    if (!payload.type || !["upvote", "downvote"].includes(payload.type)) {
      return c.json(
        { error: "Invalid feedback type. Must be 'upvote' or 'downvote'" },
        400
      );
    }
    if (!payload.messageId) {
      return c.json({ error: "Missing messageId" }, 400);
    }

    // Add timestamp if not provided
    payload.timestamp = payload.timestamp ?? new Date().toISOString();

    const isDevelopment =
      process.env.NODE_ENV === "development" || !process.env.NODE_ENV;

    if (isDevelopment) {
      console.log("\n=== Feedback Received ===");
      console.log("Type:", payload.type);
      console.log("Message ID:", payload.messageId);
      console.log(
        "Content Preview:",
        payload.content?.substring(0, 100) ?? "(none)"
      );
      console.log("Timestamp:", payload.timestamp);
      console.log("=== End Feedback ===\n");
    }

    // Call custom handler if provided
    if (options.onFeedback) {
      try {
        await options.onFeedback(payload);
      } catch (error) {
        console.error("[Feedback] Handler error:", error);
        return c.json({ error: "Feedback handler failed" }, 500);
      }
    }

    return c.json({
      success: true,
      message: "Feedback recorded",
      feedback: {
        type: payload.type,
        messageId: payload.messageId,
        timestamp: payload.timestamp
      }
    });
  });

  // Chat dispatch endpoint
  app.post(path, async (c) => {
    const apiKey = options.apiKey ?? process.env.TRAVRSE_API_KEY;
    if (!apiKey) {
      return c.json(
        { error: "Missing API key. Set TRAVRSE_API_KEY." },
        401
      );
    }

    let clientPayload: {
      messages?: Array<{ role: string; content: string; createdAt?: string }>;
      flowId?: string;
      metadata?: Record<string, unknown>;
    };
    try {
      clientPayload = await c.req.json();
    } catch (error) {
      return c.json(
        { error: "Invalid JSON body", details: error },
        400
      );
    }

    // Build the Travrse payload
    const messages = clientPayload.messages ?? [];
    // Sort messages by timestamp to ensure correct order
    const sortedMessages = [...messages].sort((a, b) => {
      const timeA = a.createdAt ? new Date(a.createdAt).getTime() : 0;
      const timeB = b.createdAt ? new Date(b.createdAt).getTime() : 0;
      return timeA - timeB;
    });
    const formattedMessages = sortedMessages.map((message) => ({
      role: message.role,
      content: message.content
    }));

    // Determine which flow to use
    const flowId = clientPayload.flowId ?? options.flowId;
    const flowConfig = options.flowConfig ?? DEFAULT_FLOW;

    const travrsePayload: Record<string, unknown> = {
      record: {
        name: "Streaming Chat Widget",
        type: "standalone",
        metadata: clientPayload.metadata || {}
      },
      messages: formattedMessages,
      options: {
        stream_response: true,
        record_mode: "virtual",
        flow_mode: flowId ? "existing" : "virtual",
        auto_append_metadata: false
      }
    };

    // Use flow ID if provided, otherwise use flow config
    if (flowId) {
      travrsePayload.flow = {
        id: flowId
      }
    } else {
      travrsePayload.flow = flowConfig;
    }

    // Development logging
    const isDevelopment = process.env.NODE_ENV === "development" || !process.env.NODE_ENV;

    if (isDevelopment) {
      console.log("\n=== Travrse Proxy Request ===");
      console.log("URL:", upstream);
      console.log("API Key Used:", apiKey ? "Yes" : "No");
      console.log("API Key (first 12 chars):", apiKey ? apiKey.substring(0, 12) : "N/A");
      console.log("Request Payload:", JSON.stringify(travrsePayload, null, 2));
    }

    const response = await fetch(upstream, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(travrsePayload)
    });

    if (isDevelopment) {
      console.log("Response Status:", response.status);
      console.log("Response Status Text:", response.statusText);

      // If there's an error, try to read and log the response body
      if (!response.ok) {
        const clonedResponse = response.clone();
        try {
          const errorBody = await clonedResponse.text();
          console.log("Error Response Body:", errorBody);
        } catch (e) {
          console.log("Could not read error response body:", e);
        }
      }
      console.log("=== End Travrse Proxy Request ===\n");
    }

    return new Response(response.body, {
      status: response.status,
      headers: {
        "Content-Type":
          response.headers.get("content-type") ?? "application/json",
        "Cache-Control": "no-store"
      }
    });
  });

  return app;
};

export const createVercelHandler = (options?: ChatProxyOptions) =>
  handle(createChatProxyApp(options));

// Export pre-configured flows
export * from "./flows/index.js";

// Export utility functions
export * from "./utils/index.js";

export default createChatProxyApp;

